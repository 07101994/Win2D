// Copyright (c) Microsoft Corporation.  All rights reserved

import "inspectable.idl";
import "Windows.Foundation.idl";

#include "../../winrt/lib/version.h"


namespace Microsoft.DirectX.Math
{
    [version(VERSION)]
    typedef struct Vector2
    {
        FLOAT X;
        FLOAT Y;
    } Vector2;


    [version(VERSION)]
    typedef struct Vector3
    {
        FLOAT X;
        FLOAT Y;
        FLOAT Z;
    } Vector3;


    [version(VERSION)]
    typedef struct Vector4
    {
        FLOAT X;
        FLOAT Y;
        FLOAT Z;
        FLOAT W;
    } Vector4;


    [version(VERSION)]
    typedef struct Matrix3x2
    {
        FLOAT M11, M12;
        FLOAT M21, M22;
        FLOAT M31, M32;
    } Matrix3x2;


    [version(VERSION)]
    typedef struct Matrix4x4
    {
        FLOAT M11, M12, M13, M14;
        FLOAT M21, M22, M23, M24;
        FLOAT M31, M32, M33, M34;
        FLOAT M41, M42, M43, M44;
    } Matrix4x4;


    [version(VERSION)]
    typedef struct Plane
    {
        Vector3 Normal;
        FLOAT D;
    } Plane;


    [version(VERSION)]
    typedef struct Quaternion
    {
        FLOAT X;
        FLOAT Y;
        FLOAT Z;
        FLOAT W;
    } Quaternion;


    // Methods for operating on Vector2 structures.
    runtimeclass Vector2Helper;

    [version(VERSION), uuid(16386710-89A9-44C5-9632-ACE9C7F6F468), exclusiveto(Vector2Helper)]
    interface IVector2HelperStatics : IInspectable
    {
        HRESULT FromValues([in] float x, [in] float y, [out, retval] Vector2* ret);
        HRESULT FromValue([in] float value, [out, retval] Vector2* ret);
        HRESULT FromPoint([in] Windows.Foundation.Point value, [out, retval] Vector2* ret);
        HRESULT FromSize([in] Windows.Foundation.Size value, [out, retval] Vector2* ret);

        HRESULT ToPoint([in] Vector2 value, [out, retval] Windows.Foundation.Point* ret);
        HRESULT ToSize([in] Vector2 value, [out, retval] Windows.Foundation.Size* ret);

        [propget] HRESULT Zero([out, retval] Vector2* ret);
        [propget] HRESULT One([out, retval] Vector2* ret);
        [propget] HRESULT UnitX([out, retval] Vector2* ret);
        [propget] HRESULT UnitY([out, retval] Vector2* ret);

        HRESULT Length([in] Vector2 value, [out, retval] float* ret);
        HRESULT LengthSquared([in] Vector2 value, [out, retval] float* ret);
        HRESULT Distance([in] Vector2 value1, [in] Vector2 value2, [out, retval] float* ret);
        HRESULT DistanceSquared([in] Vector2 value1, [in] Vector2 value2, [out, retval] float* ret);
        HRESULT Dot([in] Vector2 value1, [in] Vector2 value2, [out, retval] float* ret);
        HRESULT Normalize([in] Vector2 value, [out, retval] Vector2* ret);
        HRESULT Reflect([in] Vector2 vector, [in] Vector2 normal, [out, retval] Vector2* ret);
        HRESULT Min([in] Vector2 value1, [in] Vector2 value2, [out, retval] Vector2* ret);
        HRESULT Max([in] Vector2 value1, [in] Vector2 value2, [out, retval] Vector2* ret);
        HRESULT Clamp([in] Vector2 value1, [in] Vector2 min, [in] Vector2 max, [out, retval] Vector2* ret);
        HRESULT Lerp([in] Vector2 value1, [in] Vector2 value2, [in] float amount, [out, retval] Vector2* ret);
        HRESULT TransformByMatrix3x2([in] Vector2 position, [in] Matrix3x2 matrix, [out, retval] Vector2* ret);
        HRESULT Transform([in] Vector2 position, [in] Matrix4x4 matrix, [out, retval] Vector2* ret);
        HRESULT TransformNormalByMatrix3x2([in] Vector2 normal, [in] Matrix3x2 matrix, [out, retval] Vector2* ret);
        HRESULT TransformNormal([in] Vector2 normal, [in] Matrix4x4 matrix, [out, retval] Vector2* ret);
        HRESULT TransformByQuaternion([in] Vector2 value, [in] Quaternion rotation, [out, retval] Vector2* ret);
        HRESULT Negate([in] Vector2 value, [out, retval] Vector2* ret);
        HRESULT Add([in] Vector2 value1, [in] Vector2 value2, [out, retval] Vector2* ret);
        HRESULT Subtract([in] Vector2 value1, [in] Vector2 value2, [out, retval] Vector2* ret);
        HRESULT Multiply([in] Vector2 value1, [in] Vector2 value2, [out, retval] Vector2* ret);
        HRESULT MultiplyByScalar([in] Vector2 value1, [in] float value2, [out, retval] Vector2* ret);
        HRESULT Divide([in] Vector2 value1, [in] Vector2 value2, [out, retval] Vector2* ret);
        HRESULT DivideByScalar([in] Vector2 value1, [in] float value2, [out, retval] Vector2* ret);
    }

    [version(VERSION), static(IVector2HelperStatics, VERSION)]
    runtimeclass Vector2Helper
    {
    }


    // Methods for operating on Vector3 structures.
    runtimeclass Vector3Helper;

    [version(VERSION), uuid(DC8A85F7-C289-4DD5-B4CF-97E3DF9BF401), exclusiveto(Vector3Helper)]
    interface IVector3HelperStatics : IInspectable
    {
        HRESULT FromValues([in] float x, [in] float y, [in] float z, [out, retval] Vector3* ret);
        HRESULT FromVector2([in] Vector2 value, [in] float z, [out, retval] Vector3* ret);
        HRESULT FromValue([in] float value, [out, retval] Vector3* ret);

        [propget] HRESULT Zero([out, retval] Vector3* ret);
        [propget] HRESULT One([out, retval] Vector3* ret);
        [propget] HRESULT UnitX([out, retval] Vector3* ret);
        [propget] HRESULT UnitY([out, retval] Vector3* ret);
        [propget] HRESULT UnitZ([out, retval] Vector3* ret);

        HRESULT Length([in] Vector3 value, [out, retval] float* ret);
        HRESULT LengthSquared([in] Vector3 value, [out, retval] float* ret);
        HRESULT Distance([in] Vector3 value1, [in] Vector3 value2, [out, retval] float* ret);
        HRESULT DistanceSquared([in] Vector3 value1, [in] Vector3 value2, [out, retval] float* ret);
        HRESULT Dot([in] Vector3 vector1, [in] Vector3 vector2, [out, retval] float* ret);
        HRESULT Normalize([in] Vector3 value, [out, retval] Vector3* ret);
        HRESULT Cross([in] Vector3 vector1, [in] Vector3 vector2, [out, retval] Vector3* ret);
        HRESULT Reflect([in] Vector3 vector, [in] Vector3 normal, [out, retval] Vector3* ret);
        HRESULT Min([in] Vector3 value1, [in] Vector3 value2, [out, retval] Vector3* ret);
        HRESULT Max([in] Vector3 value1, [in] Vector3 value2, [out, retval] Vector3* ret);
        HRESULT Clamp([in] Vector3 value1, [in] Vector3 min, [in] Vector3 max, [out, retval] Vector3* ret);
        HRESULT Lerp([in] Vector3 value1, [in] Vector3 value2, [in] float amount, [out, retval] Vector3* ret);
        HRESULT Transform([in] Vector3 position, [in] Matrix4x4 matrix, [out, retval] Vector3* ret);
        HRESULT TransformNormal([in] Vector3 normal, [in] Matrix4x4 matrix, [out, retval] Vector3* ret);
        HRESULT TransformByQuaternion([in] Vector3 value, [in] Quaternion rotation, [out, retval] Vector3* ret);
        HRESULT Negate([in] Vector3 value, [out, retval] Vector3* ret);
        HRESULT Add([in] Vector3 value1, [in] Vector3 value2, [out, retval] Vector3* ret);
        HRESULT Subtract([in] Vector3 value1, [in] Vector3 value2, [out, retval] Vector3* ret);
        HRESULT Multiply([in] Vector3 value1, [in] Vector3 value2, [out, retval] Vector3* ret);
        HRESULT MultiplyByScalar([in] Vector3 value1, [in] float value2, [out, retval] Vector3* ret);
        HRESULT Divide([in] Vector3 value1, [in] Vector3 value2, [out, retval] Vector3* ret);
        HRESULT DivideByScalar([in] Vector3 value1, [in] float value2, [out, retval] Vector3* ret);
    }

    [version(VERSION), static(IVector3HelperStatics, VERSION)]
    runtimeclass Vector3Helper
    {
    }


    // Methods for operating on Vector4 structures.
    runtimeclass Vector4Helper;

    [version(VERSION), uuid(DAF39013-23B8-4BFF-B48D-55971349D0D7), exclusiveto(Vector4Helper)]
    interface IVector4HelperStatics : IInspectable
    {
        HRESULT FromValues([in] float x, [in] float y, [in] float z, [in] float w, [out, retval] Vector4* ret);
        HRESULT FromVector2([in] Vector2 value, [in] float z, [in] float w, [out, retval] Vector4* ret);
        HRESULT FromVector3([in] Vector3 value, [in] float w, [out, retval] Vector4* ret);
        HRESULT FromValue([in] float value, [out, retval] Vector4* ret);

        [propget] HRESULT Zero([out, retval] Vector4* ret);
        [propget] HRESULT One([out, retval] Vector4* ret);
        [propget] HRESULT UnitX([out, retval] Vector4* ret);
        [propget] HRESULT UnitY([out, retval] Vector4* ret);
        [propget] HRESULT UnitZ([out, retval] Vector4* ret);
        [propget] HRESULT UnitW([out, retval] Vector4* ret);

        HRESULT Length([in] Vector4 value, [out, retval] float* ret);
        HRESULT LengthSquared([in] Vector4 value, [out, retval] float* ret);
        HRESULT Distance([in] Vector4 value1, [in] Vector4 value2, [out, retval] float* ret);
        HRESULT DistanceSquared([in] Vector4 value1, [in] Vector4 value2, [out, retval] float* ret);
        HRESULT Dot([in] Vector4 vector1, [in] Vector4 vector2, [out, retval] float* ret);
        HRESULT Normalize([in] Vector4 vector, [out, retval] Vector4* ret);
        HRESULT Min([in] Vector4 value1, [in] Vector4 value2, [out, retval] Vector4* ret);
        HRESULT Max([in] Vector4 value1, [in] Vector4 value2, [out, retval] Vector4* ret);
        HRESULT Clamp([in] Vector4 value1, [in] Vector4 min, [in] Vector4 max, [out, retval] Vector4* ret);
        HRESULT Lerp([in] Vector4 value1, [in] Vector4 value2, [in] float amount, [out, retval] Vector4* ret);
        HRESULT TransformVector2([in] Vector2 position, [in] Matrix4x4 matrix, [out, retval] Vector4* ret);
        HRESULT TransformVector3([in] Vector3 position, [in] Matrix4x4 matrix, [out, retval] Vector4* ret);
        HRESULT Transform([in] Vector4 vector, [in] Matrix4x4 matrix, [out, retval] Vector4* ret);
        HRESULT TransformVector2ByQuaternion([in] Vector2 value, [in] Quaternion rotation, [out, retval] Vector4* ret);
        HRESULT TransformVector3ByQuaternion([in] Vector3 value, [in] Quaternion rotation, [out, retval] Vector4* ret);
        HRESULT TransformByQuaternion([in] Vector4 value, [in] Quaternion rotation, [out, retval] Vector4* ret);
        HRESULT Negate([in] Vector4 value, [out, retval] Vector4* ret);
        HRESULT Add([in] Vector4 value1, [in] Vector4 value2, [out, retval] Vector4* ret);
        HRESULT Subtract([in] Vector4 value1, [in] Vector4 value2, [out, retval] Vector4* ret);
        HRESULT Multiply([in] Vector4 value1, [in] Vector4 value2, [out, retval] Vector4* ret);
        HRESULT MultiplyByScalar([in] Vector4 value1, [in] float value2, [out, retval] Vector4* ret);
        HRESULT Divide([in] Vector4 value1, [in] Vector4 value2, [out, retval] Vector4* ret);
        HRESULT DivideByScalar([in] Vector4 value1, [in] float value2, [out, retval] Vector4* ret);
    }

    [version(VERSION), static(IVector4HelperStatics, VERSION)]
    runtimeclass Vector4Helper
    {
    }


    // Methods for operating on Matrix3x2 structures.
    runtimeclass Matrix3x2Helper;

    [version(VERSION), uuid(4A1F33D8-8198-44E5-8362-1A1C6B65DDEB), exclusiveto(Matrix3x2Helper)]
    interface IMatrix3x2HelperStatics : IInspectable
    {
        HRESULT FromValues([in] float m11, [in] float m12, [in] float m21, [in] float m22, [in] float m31, [in] float m32, [out, retval] Matrix3x2* ret);

        [propget] HRESULT Identity([out, retval] Matrix3x2* ret);

        HRESULT IsIdentity([in] Matrix3x2 value, [out, retval] boolean* ret);
        HRESULT Determinant([in] Matrix3x2 value, [out, retval] float* ret);
        HRESULT Translation([in] Matrix3x2 value, [out, retval] Vector2* ret);
        [overload("CreateTranslation")] HRESULT CreateTranslation([in] Vector2 position, [out, retval] Matrix3x2* ret);
        [overload("CreateTranslation")] HRESULT CreateTranslationFromValues([in] float xPosition, [in] float yPosition, [out, retval] Matrix3x2* ret);
        [overload("CreateScale")] HRESULT CreateScale([in] float scale, [out, retval] Matrix3x2* ret);
        [overload("CreateScale")] HRESULT CreateScaleFromValues([in] float xScale, [in] float yScale, [out, retval] Matrix3x2* ret);
        [overload("CreateScale")] HRESULT CreateScaleFromValuesAroundCenter([in] float xScale, [in] float yScale, [in] Vector2 centerPoint, [out, retval] Matrix3x2* ret);
        [overload("CreateSkew")] HRESULT CreateSkew([in] float radiansX, [in] float radiansY, [out, retval] Matrix3x2* ret);
        [overload("CreateSkew")] HRESULT CreateSkewAroundCenter([in] float radiansX, [in] float radiansY, [in] Vector2 centerPoint, [out, retval] Matrix3x2* ret);
        [overload("CreateRotation")] HRESULT CreateRotation([in] float radians, [out, retval] Matrix3x2* ret);
        [overload("CreateRotation")] HRESULT CreateRotationAroundCenter([in] float radians, [in] Vector2 centerPoint, [out, retval] Matrix3x2* ret);
        HRESULT Invert([in] Matrix3x2 matrix, [out] Matrix3x2* result, [out, retval] boolean* ret);
        HRESULT Lerp([in] Matrix3x2 matrix1, [in] Matrix3x2 matrix2, [in] float amount, [out, retval] Matrix3x2* ret);
        HRESULT Negate([in] Matrix3x2 value, [out, retval] Matrix3x2* ret);
        HRESULT Add([in] Matrix3x2 value1, [in] Matrix3x2 value2, [out, retval] Matrix3x2* ret);
        HRESULT Subtract([in] Matrix3x2 value1, [in] Matrix3x2 value2, [out, retval] Matrix3x2* ret);
        HRESULT Multiply([in] Matrix3x2 value1, [in] Matrix3x2 value2, [out, retval] Matrix3x2* ret);
        HRESULT MultiplyByScalar([in] Matrix3x2 value1, [in] float value2, [out, retval] Matrix3x2* ret);
    }

    [version(VERSION), static(IMatrix3x2HelperStatics, VERSION)]
    runtimeclass Matrix3x2Helper
    {
    }


    // Methods for operating on Matrix4x4 structures.
    runtimeclass Matrix4x4Helper;

    [version(VERSION), uuid(D65479A8-55B0-44ED-952F-C22EE76FDD40), exclusiveto(Matrix4x4Helper)]
    interface IMatrix4x4HelperStatics : IInspectable
    {
        HRESULT FromValues([in] float m11, [in] float m12, [in] float m13, [in] float m14, [in] float m21, [in] float m22, [in] float m23, [in] float m24, [in] float m31, [in] float m32, [in] float m33, [in] float m34, [in] float m41, [in] float m42, [in] float m43, [in] float m44, [out, retval] Matrix4x4* ret);
        HRESULT FromMatrix3x2([in] Matrix3x2 value, [out, retval] Matrix4x4* ret);

        [propget] HRESULT Identity([out, retval] Matrix4x4* ret);

        HRESULT IsIdentity([in] Matrix4x4 value, [out, retval] boolean* ret);
        HRESULT Determinant([in] Matrix4x4 value, [out, retval] float* ret);
        HRESULT Translation([in] Matrix4x4 value, [out, retval] Vector3* ret);
        HRESULT CreateBillboard([in] Vector3 objectPosition, [in] Vector3 cameraPosition, [in] Vector3 cameraUpVector, [in] Vector3 cameraForwardVector, [out, retval] Matrix4x4* ret);
        HRESULT CreateConstrainedBillboard([in] Vector3 objectPosition, [in] Vector3 cameraPosition, [in] Vector3 rotateAxis, [in] Vector3 cameraForwardVector, [in] Vector3 objectForwardVector, [out, retval] Matrix4x4* ret);
        [overload("CreateTranslation")] HRESULT CreateTranslation([in] Vector3 position, [out, retval] Matrix4x4* ret);
        [overload("CreateTranslation")] HRESULT CreateTranslationFromValues([in] float xPosition, [in] float yPosition, [in] float zPosition, [out, retval] Matrix4x4* ret);
        [overload("CreateScale")] HRESULT CreateScale([in] float scale, [out, retval] Matrix4x4* ret);
        [overload("CreateScale")] HRESULT CreateScaleFromValues([in] float xScale, [in] float yScale, [in] float zScale, [out, retval] Matrix4x4* ret);
        [overload("CreateScale")] HRESULT CreateScaleFromValuesAroundCenter([in] float xScale, [in] float yScale, [in] float zScale, [in] Vector3 centerPoint, [out, retval] Matrix4x4* ret);
        [overload("CreateRotationX")] HRESULT CreateRotationX([in] float radians, [out, retval] Matrix4x4* ret);
        [overload("CreateRotationX")] HRESULT CreateRotationXAroundCenter([in] float radians, [in] Vector3 centerPoint, [out, retval] Matrix4x4* ret);
        [overload("CreateRotationY")] HRESULT CreateRotationY([in] float radians, [out, retval] Matrix4x4* ret);
        [overload("CreateRotationY")] HRESULT CreateRotationYAroundCenter([in] float radians, [in] Vector3 centerPoint, [out, retval] Matrix4x4* ret);
        [overload("CreateRotationZ")] HRESULT CreateRotationZ([in] float radians, [out, retval] Matrix4x4* ret);
        [overload("CreateRotationZ")] HRESULT CreateRotationZAroundCenter([in] float radians, [in] Vector3 centerPoint, [out, retval] Matrix4x4* ret);
        HRESULT CreateFromAxisAngle([in] Vector3 axis, [in] float angle, [out, retval] Matrix4x4* ret);
        HRESULT CreatePerspectiveFieldOfView([in] float fieldOfView, [in] float aspectRatio, [in] float nearPlaneDistance, [in] float farPlaneDistance, [out, retval] Matrix4x4* ret);
        HRESULT CreatePerspective([in] float width, [in] float height, [in] float nearPlaneDistance, [in] float farPlaneDistance, [out, retval] Matrix4x4* ret);
        HRESULT CreatePerspectiveOffCenter([in] float left, [in] float right, [in] float bottom, [in] float top, [in] float nearPlaneDistance, [in] float farPlaneDistance, [out, retval] Matrix4x4* ret);
        HRESULT CreateOrthographic([in] float width, [in] float height, [in] float zNearPlane, [in] float zFarPlane, [out, retval] Matrix4x4* ret);
        HRESULT CreateOrthographicOffCenter([in] float left, [in] float right, [in] float bottom, [in] float top, [in] float zNearPlane, [in] float zFarPlane, [out, retval] Matrix4x4* ret);
        HRESULT CreateLookAt([in] Vector3 cameraPosition, [in] Vector3 cameraTarget, [in] Vector3 cameraUpVector, [out, retval] Matrix4x4* ret);
        HRESULT CreateWorld([in] Vector3 position, [in] Vector3 forward, [in] Vector3 up, [out, retval] Matrix4x4* ret);
        HRESULT CreateFromQuaternion([in] Quaternion quaternion, [out, retval] Matrix4x4* ret);
        HRESULT CreateFromYawPitchRoll([in] float yaw, [in] float pitch, [in] float roll, [out, retval] Matrix4x4* ret);
        HRESULT CreateShadow([in] Vector3 lightDirection, [in] Plane plane, [out, retval] Matrix4x4* ret);
        HRESULT CreateReflection([in] Plane value, [out, retval] Matrix4x4* ret);
        HRESULT Invert([in] Matrix4x4 matrix, [out] Matrix4x4* result, [out, retval] boolean* ret);
        HRESULT Decompose([in] Matrix4x4 matrix, [out] Vector3* scale, [out] Quaternion* rotation, [out] Vector3* translation, [out, retval] boolean* ret);
        HRESULT Transform([in] Matrix4x4 value, [in] Quaternion rotation, [out, retval] Matrix4x4* ret);
        HRESULT Transpose([in] Matrix4x4 matrix, [out, retval] Matrix4x4* ret);
        HRESULT Lerp([in] Matrix4x4 matrix1, [in] Matrix4x4 matrix2, [in] float amount, [out, retval] Matrix4x4* ret);
        HRESULT Negate([in] Matrix4x4 value, [out, retval] Matrix4x4* ret);
        HRESULT Add([in] Matrix4x4 value1, [in] Matrix4x4 value2, [out, retval] Matrix4x4* ret);
        HRESULT Subtract([in] Matrix4x4 value1, [in] Matrix4x4 value2, [out, retval] Matrix4x4* ret);
        HRESULT Multiply([in] Matrix4x4 value1, [in] Matrix4x4 value2, [out, retval] Matrix4x4* ret);
        HRESULT MultiplyByScalar([in] Matrix4x4 value1, [in] float value2, [out, retval] Matrix4x4* ret);
    }

    [version(VERSION), static(IMatrix4x4HelperStatics, VERSION)]
    runtimeclass Matrix4x4Helper
    {
    }


    // Methods for operating on Plane structures.
    runtimeclass PlaneHelper;

    [version(VERSION), uuid(E3DD89D3-CD96-4131-B52B-1464AA855935), exclusiveto(PlaneHelper)]
    interface IPlaneHelperStatics : IInspectable
    {
        HRESULT FromValues([in] FLOAT a, [in] FLOAT b, [in] FLOAT c, [in] FLOAT d, [out, retval] Plane* ret);
        HRESULT FromVector3([in] Vector3 normal, [in] FLOAT d, [out, retval] Plane* ret);
        HRESULT FromVector4([in] Vector4 value, [out, retval] Plane* ret);

        HRESULT CreateFromVertices([in] Vector3 point1, [in] Vector3 point2, [in] Vector3 point3, [out, retval] Plane* ret);
        HRESULT Normalize([in] Plane value, [out, retval] Plane* ret);
        HRESULT Transform([in] Plane plane, [in] Matrix4x4 matrix, [out, retval] Plane* ret);
        HRESULT TransformByQuaternion([in] Plane plane, [in] Quaternion rotation, [out, retval] Plane* ret);
        HRESULT Dot([in] Plane plane, [in] Vector4 value, [out, retval] FLOAT* ret);
        HRESULT DotCoordinate([in] Plane plane, [in] Vector3 value, [out, retval] FLOAT* ret);
        HRESULT DotNormal([in] Plane plane, [in] Vector3 value, [out, retval] FLOAT* ret);
    }

    [version(VERSION), static(IPlaneHelperStatics, VERSION)]
    runtimeclass PlaneHelper
    {
    }


    // Methods for operating on Quaternion structures.
    runtimeclass QuaternionHelper;

    [version(VERSION), uuid(02162386-E0F7-42E5-95CB-833AF98C235B), exclusiveto(QuaternionHelper)]
    interface IQuaternionHelperStatics : IInspectable
    {
        HRESULT FromValues([in] float x, [in] float y, [in] float z, [in] float w, [out, retval] Quaternion* ret);
        HRESULT FromVector3([in] Vector3 vectorPart, [in] float scalarPart, [out, retval] Quaternion* ret);

        [propget] HRESULT Identity([out, retval] Quaternion* ret);

        HRESULT IsIdentity([in] Quaternion value, [out, retval] boolean* ret);
        HRESULT Length([in] Quaternion value, [out, retval] float* ret);
        HRESULT LengthSquared([in] Quaternion value, [out, retval] float* ret);
        HRESULT Normalize([in] Quaternion value, [out, retval] Quaternion* ret);
        HRESULT Conjugate([in] Quaternion value, [out, retval] Quaternion* ret);
        HRESULT Inverse([in] Quaternion value, [out, retval] Quaternion* ret);
        HRESULT CreateFromAxisAngle([in] Vector3 axis, [in] float angle, [out, retval] Quaternion* ret);
        HRESULT CreateFromYawPitchRoll([in] float yaw, [in] float pitch, [in] float roll, [out, retval] Quaternion* ret);
        HRESULT CreateFromRotationMatrix([in] Matrix4x4 matrix, [out, retval] Quaternion* ret);
        HRESULT Dot([in] Quaternion quaternion1, [in] Quaternion quaternion2, [out, retval] float* ret);
        HRESULT Slerp([in] Quaternion quaternion1, [in] Quaternion quaternion2, [in] float amount, [out, retval] Quaternion* ret);
        HRESULT Lerp([in] Quaternion quaternion1, [in] Quaternion quaternion2, [in] float amount, [out, retval] Quaternion* ret);
        HRESULT Concatenate([in] Quaternion value1, [in] Quaternion value2, [out, retval] Quaternion* ret);
        HRESULT Negate([in] Quaternion value, [out, retval] Quaternion* ret);
        HRESULT Add([in] Quaternion value1, [in] Quaternion value2, [out, retval] Quaternion* ret);
        HRESULT Subtract([in] Quaternion value1, [in] Quaternion value2, [out, retval] Quaternion* ret);
        HRESULT Multiply([in] Quaternion value1, [in] Quaternion value2, [out, retval] Quaternion* ret);
        HRESULT MultiplyByScalar([in] Quaternion value1, [in] float value2, [out, retval] Quaternion* ret);
        HRESULT Divide([in] Quaternion value1, [in] Quaternion value2, [out, retval] Quaternion* ret);
    }

    [version(VERSION), static(IQuaternionHelperStatics, VERSION)]
    runtimeclass QuaternionHelper
    {
    }
}
